// Generated by CoffeeScript 1.9.3
(function() {
  var FILE_IDX_INC, HelperProcess, asdf, crypto, dbg, debug, fs, gitParser, log, logPath, moment, net, path, pipePath, util,
    slice = [].slice;

  fs = require('fs-plus');

  net = require('net');

  path = require('path');

  util = require('util');

  crypto = require('crypto');

  moment = require('moment');

  gitParser = require('gitignore-parser');

  FILE_IDX_INC = 2;

  debug = process.argv[2];

  logPath = path.join(process.cwd(), 'find-all-words_process.log');

  fs.removeSync(logPath);

  log = function() {
    var args, time;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    time = moment().format('MM-DD HH:mm:ss');
    return fs.appendFileSync(logPath, time + ' ' + args.join(' ') + '\n');
  };

  log('-- starting helper process --');

  log('-- node version', process.version);

  dbg = (debug ? log : function() {});

  dbg('-- debug mode');

  pipePath = process.platform === 'win32' ? '\\\\.\\pipe\\atomfindallwords.sock' : '/tmp/atomfindallwords.sock';

  asdf = 1;

  process.on('uncaughtException', function(err) {
    log('-- uncaughtException --');
    log(util.inspect(err, {
      depth: null
    }));
    return process.exit(1);
  });

  HelperProcess = (function() {
    function HelperProcess() {
      var lastConnection, server;
      lastConnection = Date.now();
      this.connections = [];
      server = net.createServer();
      fs.removeSync(pipePath);
      server.listen(pipePath, (function(_this) {
        return function() {
          return log('server listening on', process.pid);
        };
      })(this));
      server.on('error', function(err) {
        return log('server error', err.message);
      });
      server.on('connection', (function(_this) {
        return function(socket) {
          var connIdx, destroy;
          connIdx = _this.connections.length;
          _this.connections[connIdx] = socket;
          log('connection opened', connIdx);
          destroy = function() {
            log('connection ended', connIdx);
            delete _this.connections[connIdx];
            socket.destroy();
            return socket = null;
          };
          socket.on('data', function(buf) {
            var msg;
            msg = JSON.parse(buf.toString());
            dbg('recvd cmd', connIdx, msg.cmd);
            return _this[msg.cmd](connIdx, msg);
          });
          socket.on('error', function(err) {
            log('socket error', err.message);
            return destroy();
          });
          return socket.on('end', destroy);
        };
      })(this));
      setInterval((function(_this) {
        return function() {
          var connection, j, len, ref;
          log('setInterval', '\n', (new Date(lastConnection)).toString(), '\n', (new Date).toString());
          ref = _this.connections;
          for (j = 0, len = ref.length; j < len; j++) {
            connection = ref[j];
            if (!(connection)) {
              continue;
            }
            log('lastConnection = Date.now()');
            lastConnection = Date.now();
            break;
          }
          if (Date.now() > lastConnection + 200e3) {
            log('-- terminating idle process');
            return server.close(function() {
              fs.removeSync(pipePath);
              log('-- terminated');
              return process.exit(0);
            });
          }
        };
      })(this), 60e3);
    }

    HelperProcess.prototype.send = function(connIdx, cmd, msg) {
      var socket;
      if ((socket = this.connections[connIdx])) {
        msg.cmd = cmd;
        return socket.write(JSON.stringify(msg));
      }
    };

    HelperProcess.prototype.broadcast = function(cmd, msg) {
      var j, len, ref, results, socket;
      msg.cmd = cmd;
      ref = this.connections;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        socket = ref[j];
        if (socket) {
          results.push(socket.write(JSON.stringify(msg)));
        }
      }
      return results;
    };

    HelperProcess.prototype.init = function(connIdx, opts) {
      this.opts = opts;
      log('init', this.opts.newProcess);
      if (this.opts.newProcess) {
        this.loadAllData();
      }
      return this.scanAll(connIdx);
    };

    HelperProcess.prototype.updateOpts = function(connIdx, opts) {
      this.opts = opts;
      return this.scanAll(connIdx);
    };

    HelperProcess.prototype.getFilesForWord = function(connIdx, msg) {
      var assign, caseSensitive, exactWord, filePaths, none, onFileIndexes, word;
      word = msg.word, caseSensitive = msg.caseSensitive, exactWord = msg.exactWord, assign = msg.assign, none = msg.none;
      filePaths = {};
      onFileIndexes = (function(_this) {
        return function(indexes) {
          var idx, j, len, results;
          results = [];
          for (j = 0, len = indexes.length; j < len; j++) {
            idx = indexes[j];
            if (idx) {
              results.push(filePaths[_this.filesByIndex[idx].path] = true);
            }
          }
          return results;
        };
      })(this);
      if (assign && none) {
        this.traverseWordTrie(word, caseSensitive, exactWord, 'all', onFileIndexes);
      } else {
        if (assign) {
          this.traverseWordTrie(word, caseSensitive, exactWord, 'assign', onFileIndexes);
        }
        if (none) {
          this.traverseWordTrie(word, caseSensitive, exactWord, 'none', onFileIndexes);
        }
      }
      return this.send(connIdx, 'filesForWord', {
        files: Object.keys(filePaths),
        word: word,
        caseSensitive: caseSensitive,
        exactWord: exactWord,
        assign: assign,
        none: none
      });
    };

    HelperProcess.prototype.scanAll = function(connIdx) {
      var j, k, len, len1, optPath, projPath, ref, ref1;
      this.filesChecked = this.filesAdded = this.filesRemoved = this.indexesAdded = this.timeMismatchCount = this.md5MismatchCount = this.changeCount = 0;
      this.setAllFileRemoveMarkers();
      ref = this.opts.paths;
      for (j = 0, len = ref.length; j < len; j++) {
        optPath = ref[j];
        dbg('scanning', optPath);
        if (this.scanProject(optPath)) {
          continue;
        }
        ref1 = fs.listSync(optPath);
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          projPath = ref1[k];
          if (fs.isDirectorySync(projPath)) {
            this.scanProject(projPath);
          }
        }
      }
      this.removeMarkedFiles();
      if (this.changeCount) {
        this.saveAllData();
      }
      return this.broadcast('scanned', {
        indexesAdded: this.indexesAdded,
        filesChecked: this.filesChecked,
        filesAdded: this.filesAdded,
        filesRemoved: this.filesRemoved,
        timeMismatchCount: this.timeMismatchCount,
        md5MismatchCount: this.md5MismatchCount,
        changeCount: this.changeCount
      });
    };

    HelperProcess.prototype.scanProject = function(projPath) {
      var e, giPath, gitignore, gitignoreTxt, onDir, onFile;
      if (this.opts.gitignore && !fs.isDirectorySync(path.join(projPath, '.git'))) {
        return false;
      }
      gitignore = this.opts.gitignore && (function() {
        try {
          giPath = path.join(projPath, '.gitignore');
          gitignoreTxt = fs.readFileSync(giPath, 'utf8');
          return gitParser.compile(gitignoreTxt + '\n.git\n');
        } catch (_error) {
          e = _error;
          return null;
        }
      })();
      onDir = (function(_this) {
        return function(dirPath) {
          return !gitignore || gitignore.accepts(path.basename(dirPath));
        };
      })(this);
      onFile = (function(_this) {
        return function(filePath) {
          var sfx;
          sfx = path.extname(filePath).toLowerCase();
          if (((sfx === '' && _this.opts.suffixes.empty) || (sfx === '.' && _this.opts.suffixes.dot) || _this.opts.suffixes[sfx]) && (!gitignore || gitignore.accepts(path.basename(filePath)))) {
            return _this.checkFile(filePath);
          }
        };
      })(this);
      fs.traverseTreeSync(projPath, onFile, onDir);
      return true;
    };

    HelperProcess.prototype.checkFile = function(filePath) {
      var after, allWords, before, e, file, fileIndex, fileMd5, fileTime, idx, j, k, l, len, len1, len2, oldFile, parts, ref, results, stats, text, word, wordRegex, wordsAssign, wordsAssignList, wordsNone, wordsNoneList;
      this.filesChecked++;
      try {
        stats = fs.statSync(filePath);
      } catch (_error) {
        e = _error;
        log('ERROR on file stat, skipping', filePath, e.message);
        return;
      }
      if (!stats.isFile()) {
        return;
      }
      if ((oldFile = this.filesByPath[filePath])) {
        delete oldFile.remove;
      } else {
        this.filesAdded++;
      }
      fileTime = stats.mtime.getTime();
      if (fileTime === (oldFile != null ? oldFile.time : void 0)) {
        return;
      }
      this.timeMismatchCount++;
      try {
        text = fs.readFileSync(filePath);
      } catch (_error) {
        e = _error;
        log('ERROR reading file, skipping', filePath, e.message);
        return;
      }
      wordsAssign = {};
      wordsNone = {};
      wordRegex = new RegExp(this.opts.wordRegexStr, 'g');
      while ((parts = wordRegex.exec(text))) {
        word = parts[0];
        if (!(word in wordsAssign)) {
          idx = wordRegex.lastIndex;
          before = text.slice(0, idx - word.length);
          after = text.slice(idx);
          if (/^\s*=/.test(after) || /function\s+$/.test(before) || /for\s+(\w+,)?\s*$/.test(before) && /^\s+(in|of)\s/.test(after) || /\{([^,}]*,)*([^,:}]+:)?\s*$/.test(before) && /^\s*(,[^,}]* )*\}\s*=/.test(after) || /\[([^,\]]*,)*\s*$/.test(before) && /^\s*(,[^,\]]*)*\]\s*=/.test(after)) {
            wordsAssign[word] = true;
            delete wordsNone[word];
          } else {
            wordsNone[word] = true;
          }
        }
      }
      wordsAssignList = Object.keys(wordsAssign).sort();
      wordsNoneList = Object.keys(wordsNone).sort();
      allWords = wordsAssignList.join(';') + ';;' + wordsNoneList.join(';');
      fileMd5 = crypto.createHash('md5').update(allWords).digest("hex");
      if (!(fileIndex = oldFile != null ? oldFile.index : void 0)) {
        ref = this.filesByIndex;
        for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
          file = ref[idx];
          if (!file) {
            break;
          }
        }
        fileIndex = idx;
      }
      this.filesByPath[filePath] = this.filesByIndex[fileIndex] = {
        path: filePath,
        index: fileIndex,
        time: fileTime,
        md5: fileMd5
      };
      if (fileMd5 === (oldFile != null ? oldFile.md5 : void 0)) {
        return;
      }
      this.md5MismatchCount++;
      this.changeCount++;
      if (oldFile) {
        this.removeFileIndexFromTrie(oldFile.index);
      }
      for (k = 0, len1 = wordsAssignList.length; k < len1; k++) {
        word = wordsAssignList[k];
        this.addWordFileIndexToTrie(word, fileIndex, 'as');
      }
      results = [];
      for (l = 0, len2 = wordsNoneList.length; l < len2; l++) {
        word = wordsNoneList[l];
        results.push(this.addWordFileIndexToTrie(word, fileIndex, 'no'));
      }
      return results;
    };

    HelperProcess.prototype.setAllFileRemoveMarkers = function() {
      var file, j, len, ref, results;
      ref = this.filesByIndex;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        file = ref[j];
        if (file) {
          results.push(file.remove = true);
        }
      }
      return results;
    };

    HelperProcess.prototype.removeMarkedFiles = function() {
      var file, j, len, ref, results;
      ref = this.filesByIndex;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        file = ref[j];
        if (!(file != null ? file.remove : void 0)) {
          continue;
        }
        this.filesRemoved++;
        this.changeCount++;
        this.removeFileIndexFromTrie(file.index);
        delete this.filesByPath[file.path];
        results.push(delete this.filesByIndex[file.index]);
      }
      return results;
    };

    HelperProcess.prototype.removeFileIndexFromTrie = function(fileIndex) {
      return this.traverseWordTrie('', false, false, 'all', function(fileIndexes) {
        var fileIdx, idx, j, len;
        for (idx = j = 0, len = fileIndexes.length; j < len; idx = ++j) {
          fileIdx = fileIndexes[idx];
          if (!(fileIdx === fileIndex)) {
            continue;
          }
          fileIndexes[idx] = 0;
          return;
        }
      });
    };

    HelperProcess.prototype.setFileIndexesInTrie = function(word, fileIndexes, type) {
      var node;
      this.indexesAdded += fileIndexes.length;
      node = this.getAddWordNodeFromTrie(word);
      return node[type] = fileIndexes;
    };

    HelperProcess.prototype.addWordFileIndexToTrie = function(word, fileIndex, type) {
      var fileIdx, fileIndexes, idx, j, len, newFileIndexes, newLen, node, oldLen;
      this.indexesAdded++;
      node = this.getAddWordNodeFromTrie(word);
      fileIndexes = node[type] != null ? node[type] : node[type] = new Int32Array(FILE_IDX_INC);
      for (idx = j = 0, len = fileIndexes.length; j < len; idx = ++j) {
        fileIdx = fileIndexes[idx];
        if (!(fileIdx === 0)) {
          continue;
        }
        fileIndexes[idx] = fileIndex;
        return;
      }
      oldLen = fileIndexes.length;
      newLen = oldLen + FILE_IDX_INC;
      newFileIndexes = new Int32Array(newLen);
      newFileIndexes[FILE_IDX_INC - 1] = fileIndex;
      newFileIndexes.set(fileIndexes, FILE_IDX_INC);
      return node[type] = newFileIndexes;
    };

    HelperProcess.prototype.getAddWordNodeFromTrie = function(word) {
      var j, lastNode, len, letter, node;
      node = this.wordTrie;
      for (j = 0, len = word.length; j < len; j++) {
        letter = word[j];
        lastNode = node;
        if (!(node = node[letter])) {
          node = lastNode[letter] = {};
        }
      }
      return node;
    };

    HelperProcess.prototype.traverseWordTrie = function(wordIn, caseSensitive, exactWord, type, onFileIndexes) {
      var visitNode;
      visitNode = function(node, wordLeft, wordForNode) {
        var childNode, letter, results;
        if (!wordLeft) {
          if (node.as && (type === 'all' || type === 'assign')) {
            onFileIndexes(node.as, wordForNode, 'as');
          }
          if (node.no && (type === 'all' || type === 'none')) {
            onFileIndexes(node.no, wordForNode, 'no');
          }
          if (exactWord) {
            return;
          }
        }
        results = [];
        for (letter in node) {
          childNode = node[letter];
          if (letter.length === 1) {
            if (!wordLeft || letter === wordLeft[0] || !caseSensitive && letter.toLowerCase() === wordLeft[0].toLowerCase()) {
              results.push(visitNode(childNode, wordLeft.slice(1), wordForNode + letter));
            } else {
              results.push(void 0);
            }
          }
        }
        return results;
      };
      return visitNode(this.wordTrie, wordIn, '');
    };

    HelperProcess.prototype.saveAllData = function() {
      var fd, json, jsonBuf, jsonLen, tmpPath;
      dbg('saving to', this.opts.dataPath);
      tmpPath = this.opts.dataPath + '.tmp';
      fd = fs.openSync(tmpPath, 'w');
      json = JSON.stringify(this.filesByIndex);
      while ((jsonLen = Buffer.byteLength(json)) % 4) {
        json += ' ';
      }
      jsonBuf = new Buffer(4 + jsonLen);
      jsonBuf.writeInt32BE(jsonLen, 0);
      jsonBuf.write(json, 4);
      fs.writeSync(fd, jsonBuf, 0, jsonBuf.length);
      this.traverseWordTrie('', false, false, 'all', function(fileIndexes, word, type) {
        var bufHdr, bufIdx, bufIdxLen, hdr, hdrLen, i, j, ref;
        hdr = word + ';' + type;
        while (hdr.length % 4) {
          hdr += ' ';
        }
        hdrLen = Buffer.byteLength(hdr);
        bufHdr = new Buffer(4 + hdrLen);
        bufHdr.writeInt32BE(hdrLen, 0);
        bufHdr.write(hdr, 4);
        fs.writeSync(fd, bufHdr, 0, bufHdr.length);
        bufIdxLen = fileIndexes.length * 4;
        bufIdx = new Buffer(4 + bufIdxLen);
        bufIdx.writeInt32BE(bufIdxLen, 0);
        for (i = j = 0, ref = fileIndexes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          bufIdx.writeInt32BE(fileIndexes[i], 4 + i * 4);
        }
        return fs.writeSync(fd, bufIdx, 0, bufIdx.length);
      });
      fs.closeSync(fd);
      fs.removeSync(this.opts.dataPath);
      fs.moveSync(tmpPath, this.opts.dataPath);
      return dbg('saved');
    };

    HelperProcess.prototype.loadAllData = function() {
      var buf, e, fd, file, fileIndexes, hdr, hdrLen, i, idxLen, j, jsonLen, k, len, readLen, ref, ref1, ref2, type, word;
      log('loading from', this.opts.dataPath);
      this.filesByIndex = [];
      this.filesByPath = {};
      this.wordTrie = {};
      try {
        fd = fs.openSync(this.opts.dataPath, 'r');
        readLen = function() {
          var buf, bytesRead;
          buf = new Buffer(4);
          bytesRead = fs.readSync(fd, buf, 0, 4);
          if (!bytesRead) {
            return 0;
          } else {
            return buf.readInt32BE(0);
          }
        };
        jsonLen = readLen();
        buf = new Buffer(jsonLen);
        fs.readSync(fd, buf, 0, jsonLen);
        this.filesByIndex = JSON.parse(buf.toString());
        ref = this.filesByIndex;
        for (j = 0, len = ref.length; j < len; j++) {
          file = ref[j];
          if (file) {
            this.filesByPath[file.path] = file;
          }
        }
        while ((hdrLen = readLen())) {
          buf = new Buffer(hdrLen);
          fs.readSync(fd, buf, 0, hdrLen);
          hdr = buf.toString();
          ref1 = hdr.split(';'), word = ref1[0], type = ref1[1];
          type = type.slice(0, 2);
          idxLen = readLen();
          buf = new Buffer(idxLen);
          fs.readSync(fd, buf, 0, idxLen);
          fileIndexes = new Int16Array(idxLen / 4);
          for (i = k = 0, ref2 = idxLen / 4; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
            fileIndexes[i] = buf.readInt32BE(i * 4, true);
          }
          this.setFileIndexesInTrie(word, fileIndexes, type);
        }
        return log('loaded', this.filesByIndex.length, Object.keys(this.wordTrie).length);
      } catch (_error) {
        e = _error;
        this.filesByIndex = [];
        this.filesByPath = {};
        this.wordTrie = {};
        return log('Warning: data file read err', util.inspect(e));
      }
    };

    HelperProcess.prototype.destroy = function() {};

    return HelperProcess;

  })();

  new HelperProcess;

}).call(this);
