// Generated by CoffeeScript 1.9.3
(function() {
  var HelperProcess, crypto, fs, gitParser, log, path, util,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  log = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, args);
  };

  fs = require('fs-plus');

  path = require('path');

  util = require('util');

  crypto = require('crypto');

  gitParser = require('gitignore-parser');

  HelperProcess = (function() {
    function HelperProcess() {
      this.filesByPath = {};
      this.filesByIndex = [];
      this.wordTrie = {};
      process.on('message', (function(_this) {
        return function(msg) {
          return _this[msg.cmd](msg);
        };
      })(this));
      process.on('disconnect', (function(_this) {
        return function() {
          return _this.destroy();
        };
      })(this));
    }

    HelperProcess.prototype.send = function(msg) {
      return process.send(msg);
    };

    HelperProcess.prototype.init = function(opts) {
      this.opts = opts;

      /*
        packed format (53 bits)
           5 suffix
          16 filePath
          32 char offset
       */
      log('@opts', this.opts);
      return this.checkAllProjects();
    };

    HelperProcess.prototype.updateOpts = function(opts) {
      this.opts = opts;
      return this.checkAllProjects();
    };

    HelperProcess.prototype.checkAllProjects = function() {
      var i, len, optPath, projPath, ref, results;
      ref = this.opts.paths;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        optPath = ref[i];
        if (this.checkOneProject(optPath)) {
          continue;
        }
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = fs.listSync(optPath);
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            projPath = ref1[j];
            results1.push(this.checkOneProject(projPath));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    HelperProcess.prototype.checkOneProject = function(projPath) {
      var e, giPath, gitignore, onDir, onFile;
      try {
        giPath = path.join(projPath, '.gitignore');
        gitignore = gitParser.compile(fs.readFileSync(giPath, 'utf8'));
      } catch (_error) {
        e = _error;
        return false;
      }
      onDir = (function(_this) {
        return function(dirPath) {
          var dir;
          dir = path.basename(dirPath);
          if (dir === '.git') {
            return false;
          }
          return !_this.opts.gitignore || gitignore.accepts(dir);
        };
      })(this);
      onFile = (function(_this) {
        return function(filePath) {
          var base, sfx;
          filePath = filePath.toLowerCase();
          base = path.basename(filePath);
          sfx = path.extname(filePath);
          if (((sfx === '' && _this.opts.suffixes.empty) || (sfx === '.' && _this.opts.suffixes.dot) || _this.opts.suffixes[sfx]) && (!_this.opts.gitignore || gitignore.accepts(base))) {
            return _this.checkOneFile(filePath);
          }
        };
      })(this);
      fs.traverseTreeSync(projPath, onFile, onDir);
      return true;
    };

    HelperProcess.prototype.checkOneFile = function(filePath) {
      var e, fileTime, oldFile, parts, ref, stats, text, wordList, wordRegex, words;
      log('checkOneFile', filePath);
      try {
        stats = fs.statSync(filePath);
      } catch (_error) {
        e = _error;
        log('ERROR on file stat, skipping', filePath, e.message);
        return;
      }
      if (!stats.isFile()) {
        return;
      }
      fileTime = stats.mtime.getTime();
      if ((oldFile = this.filesByPath[filePath]) && fileTime === oldFile.time) {
        return;
      }
      try {
        text = fs.readFileSync(filePath);
      } catch (_error) {
        e = _error;
        log('ERROR reading file, skipping', filePath, e.message);
        return;
      }
      words = {};
      if (!this.regexStr) {
        try {
          wordRegex = new RegExp(this.opts.wordRegex, 'g');
          this.regexStr = this.opts.wordRegex;
        } catch (_error) {
          e = _error;
          log('ERROR parsing word regex, using "[^\d]\\w*"', regexStr, e.message);
          this.regexStr = "\\w+";
        }
      }
      wordRegex = new RegExp(this.regexStr, 'g');
      while ((parts = wordRegex.exec(text))) {
        if (ref = parts[0], indexOf.call(words, ref) < 0) {
          words[parts[0]] = true;
        }
      }
      wordList = Object.keys(words).sort();
      return this.checkWords(filePath, fileTime, oldFile, wordList);
    };

    HelperProcess.prototype.checkWords = function(filePath, fileTime, oldFile, wordList) {
      var fileIndex, fileMd5, ref;
      fileIndex = (ref = oldFile != null ? oldFile.index : void 0) != null ? ref : this.filesByIndex.length;
      fileMd5 = crypto.createHash('md5').update(wordList.join(';')).digest("hex");
      this.filesByPath[filePath] = this.filesByIndex[fileIndex] = {
        path: filePath,
        index: fileIndex,
        time: fileTime,
        md5: fileMd5
      };
      if (fileMd5 === (oldFile != null ? oldFile.md5 : void 0)) {
        return;
      }
      if (oldFile) {
        return this.traverseTrie((function(_this) {
          return function(word, fileIndexes) {
            return fileIndexes.length !== 0;
          };
        })(this));
      }
    };

    HelperProcess.prototype.traverseTrie = function() {
      var visitNode;
      visitNode = function(node, word) {
        var childNode, haveChild, letter;
        haveChild = false;
        for (letter in node) {
          childNode = node[letter];
          if (letter === 'fi') {
            if (!onFileIndexes(word, childNode)) {
              delete node.fi;
            } else {
              haveChild = true;
            }
          } else {
            if (!visitNode(childNode, word + letter)) {
              delete node[letter];
            } else {
              haveChild = true;
            }
          }
        }
        return haveChild;
      };
      return visitNode(this.wordTrie, '');
    };

    HelperProcess.prototype.destroy = function() {};

    return HelperProcess;

  })();

  new HelperProcess;

}).call(this);
